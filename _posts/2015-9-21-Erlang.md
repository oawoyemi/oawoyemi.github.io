---
layout: post
title: Erlang
---
Erlang OTP is best known for its Actor implementation with Supervision Trees: that provides the semantics for self-healing


## Supervision
Supervision means that normal requests and responses (including negative ones such as validation errors) flow separately from failures: while the former are exchanged between the user and the service, the latter travel from the service to its supervisor.


Designed for programming real-time control systems. The combination of lightweight isolated processes, asynchronous message passing with pattern matching, and controlled error propagation has been proven to be very effective. One of our main contributions lies in the integration of Erlang’s programming model into a full-fledged object-oriented and functional language.

#### Is Erlang Difficult?
No—but it’s different.

Erlang does not have “A C-like syntax to make it easy to learn.” It is not “Object Oriented,” it does not have “Mutable state,” and it’s a “Functional programming Language.”

It’s really a very small and simple language.

You might be wondering what Erlang code looks like. Erlang makes heavy use of a pattern matching syntax; here’s a small example of Erlang code (from the new Erlang book):
```
-module(geometry).
-export([area/1]).
area({rectangle, Width, Ht}) -> Width * Ht;
area({square, X}) -> X * X;
area({circle, R}) -> 3.14159 * R * R.
Now we’ll compile and run it in the Erlang shell:

1> c(geometry). {ok,geometry}
2> geometry:area({rectangle, 10, 5}). 50
3> geometry:area({circle, 1.4}). 6.15752
```
- **Invariant variables** - note that variables begin with an uppercase letter
- #### Processes
Erlang forces you to write actors (processes) that will share no information with other bits of code unless they pass messages to each other.
    - Every communication is explicit, traceable and safe.
- #### Atoms
There is a reason why variables names can't begin with a lowercase character: atoms.
  - Atoms are literals, constants with their own name for value.
  - An atom should be enclosed in single quotes (') if it does not begin with a lower-case letter or if it contains other characters than alphanumeric characters, underscore _ , or @.
  - atoms should not be generated dynamically for whatever reason,  The atom table is not garbage collected, and so atoms will accumulate until the system tips over (8 bytes/atom in a 64 bit system)
- **Unbound variables** - First, X and Y had no value and were thus considered unbound variables
- Lists The | we used is named the cons operator (constructor). In fact, any list can be built with only cons and values:
- List Comprehension The recipe for list comprehensions in Erlang is therefore
      NewList = [Expression || Pattern <- List, Condition1, Condition2…]

  - The part ```Pattern <- List``` is named a Generator expression which may have a cardinality of 0..N.
- Modules are a bunch of functions regrouped in a single file, under a single name. Additionally, all functions in Erlang must be defined in **modules**.
- They are simple expressions represented by text that will be replaced before the code is compiled for the VM. Such macros are mainly useful to avoid having magic values floating around your modules. A macro is defined as a module attribute of the form: ```-define(MACRO, some_value)```. and is used as ```?MACRO``` inside any function defined in the module. A 'function' macro could be written as ```-define(sub(X,Y), X-Y).``` and used like ```?sub(23,47)```, later replaced by 23-47 by the compiler.
- ***Guard expressions*** - Note that a basic rule for guard expression is they must return true to succeed.
    - The comma (,) acts in a similar manner to the operator and also and the semicolon (;) acts a bit like or else
- One negative point about guards is that they will not accept user-defined functions because of side effects. Erlang is not a purely functional programming language (like Haskell is) because it relies on side effects a lot

### BIFs
built-in functions (BIFs) are usually functions that could not be implemented in pure Erlang, and as such are defined in C, or whichever language Erlang happens to be implemented on (it was Prolog in the 80's). There are still some BIFs that could be done in Erlang but were still implemented in C in order to provide more speed to common operations.

#### Lists
```
 List = [2,3,4].
80> [Head|Tail] = List.
[1,2,3,4]
81> Head.
1
82> Tail.
[2,3,4]
```
The | we used is named the cons operator (constructor). In fact, any list can be built with only cons and values:
```
21> [2 | [1 | []]].
[2,1]
```


#### List comprehensions
```
1> [2*N || N <- [1,2,3,4]].
[2,4,6,8]

2> [X || X <- [1,2,3,4,5,6,7,8,9,10], X rem 2 =:= 0].
[2,4,6,8,10]
```
 NewList = [Expression || Pattern <- List, Condition1, Condition2, ... ConditionN]

## Shell
```f(variable).``` erase variable
```f().``` erase all session variables
